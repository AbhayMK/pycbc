#! /usr/bin/env python

__prog__ = 'pycbc_randr_by_snr'
__author__ = 'Collin Capano <collin.capano@ligo.org>'
__description__ = 'Resets the distance distribution in a sim_inspiral table based on desired SNR. The SNRs are chosen randomly from a given range.'

import sqlite3
import numpy
import os, sys
import random
import time
from scipy import stats
from optparse import OptionParser

import lal
import lalsimulation as lalsim

from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw import table
from glue.ligolw import dbtables
from glue.ligolw.utils import process

from pylal import ligolw_sqlutils as sqlutils

from pycbc import filter
from pycbc.overlaps import waveform_utils
from pycbc.overlaps import overlap_utils

def create_sim_params_table(connection, delete_old=True):
    crs = connection.cursor()
    if delete_old:
        crs.execute('DROP TABLE IF EXISTS sim_inspiral_params')
    sqlquery = """
        CREATE TABLE IF NOT EXISTS
            sim_inspiral_params
            (simulation_id, ifo, event_time, event_time_ns, sigmasq,
            min_vol, weight);
        CREATE INDEX IF NOT EXISTS
            sip_sid_idx
        ON
            sim_inspiral_params (simulation_id);
        """
    crs.executescript(sqlquery)

def r_uniform_in_volume(r1, r2, N):
    xi = numpy.random.uniform(0., 1., size=N)
    return (xi*r2**3. + (1.-xi)*r1**3.)**(1./3)

def r_uniform_in_distance(r1, r2, N):
    return numpy.random.uniform(r1, r2, size=N)

def r_in_modified_gamma(r0, rmax, theta=2., r0_at='mode', N=1):
    # FIXME: I think I can generalize beyond k=2
    k = 2.
    if r0_at == 'mode':
        g = (k - 1.)*theta
    elif r0_at == 'mean':
        g = k*theta
    else:
        raise ValueError("r0_at must be either 'mode' or 'mean'")
    # draw a value from the gamma distribution
    x = stats.gamma.rvs(k, scale=theta, size=N)
    # scale to r
    return rmax * r0 * g / (x*(rmax-r0) + r0*g)

def modified_gamma_weight(r, r0, rmax, theta=2., r0_at='mode'):
    # FIXME: I think I can generalize beyond k=2
    k = 2.
    if r0_at == 'mode':
        g = (k - 1.)*theta
    elif r0_at == 'mean':
        g = k*theta
    else:
        raise ValueError("r0_at must be either 'mode' or 'mean'")
    beta = r0 * g / (theta * (1. - r0/rmax))
    weight = (rmax/(rmax-r))* r**5. * numpy.exp(beta*(1./r - 1./rmax))/beta**2.
    return weight

def get_weights(distribution, r, r1, r2):
    if distribution == "volume":
        min_vol = (4./3)*numpy.pi*r1**3.
        weight = (4./3)*numpy.pi*(r2**3. - r1**3.)
    elif distribution == "distance":
        min_vol = (4./3)*numpy.pi*r1**3.
        weight = 4.*numpy.pi*(r2-r1) * r**2. 
    else:
        raise ValueError("unrecognized distribution %s" %(distribution))
    return min_vol, weight

parser = OptionParser(description = __description__)
parser.add_option("-t", "--tmp-space", action = "store", type = "string", default = None, metavar = "PATH", help = "Location of local disk on which to do work. This is used to enhance performance in a networked environment.")
parser.add_option("-p", "--psd-model", help = "What PSD to use for overlaps. Options are %s." %(', '.join(overlap_utils.get_psd_models())))
parser.add_option("-A", "--asd-file", help = "Load the PSD from a dat file containing an ASD. If both this and psd-model specified, this will take precedence.")
parser.add_option('-f', '--waveform-f-min', type = 'float', help = "Frequency at which to start the waveform generation (in Hz).")
parser.add_option('-F', '--overlap-f-min', type = 'float', help = "Frequency at which to start the overlap (in Hz). Note: This must be larger than waveform-f-min.")
parser.add_option('-r', '--default-sample-rate', type = 'int', default = 4096, help = "Default sample rate to use (in Hz). Must be a power of 2. Only needed if injections' f_final column is not populated. If they are populated, the smallest sample rate giving a Nyquist frequency greater than the f_final of each injection will be used. Default is 4096.")
parser.add_option('-i', '--ifo', help = "What ifo to inject into. If none specified, no response function will be applied to the injections, and --use-effective-distance must be turned on.")
parser.add_option('--use-effective-distance', action='store_true', default=False, help='Set the inclination angle to 0, and fix the sky location angles and polarization to be 0. A weight of 1/2.26 will be applied to the distance. Otherwise, angles for the sky-location will be drawn uniformly on the unit sphere.')
parser.add_option('-s', '--min-snr', type = 'float', help = 'Set the minimum SNR to use.')
parser.add_option('-S', '--max-snr', type = 'float', help = 'Set the maximum SNR to use; must be larger than min-snr. To use an exact snr, set to the same value as min-snr.')
parser.add_option('', '--fiducial-snr', type='float', help='Set the fiducial SNR; needed for the Gamma distribution.')
parser.add_option('', '--fixed-distance-range', metavar='MIN_D,MAX_D', help='Instead of using the SNR to determine the limits from which to draw the distance, use the given range for all injections.')
parser.add_option('-d', '--distribution', default='distance', help = 'What distribution to make the injections uniform in. Options are "distance", "volume", or "gamma". If "distance", the distance distribution of the injections will be uniform in distance. If "volume", uniform in volume. If "gamma", distances will be drawn from the Gamma distribution p(x; k=2, theta=2) scaled such that the distance at the max-snr is at x=0 and the mode is at the distance corresponding to the fiducial-snr. Requires fiducial-snr to be specified. Default is distance.')
parser.add_option('', '--scale-by-chirp-dist', action='store_true', help='Scale the distance by the chirp distance relative to a 1.4/1.4 binary. Only can use if fixed-distance-range is on.')
parser.add_option('', '--seed', type = 'int', default = int((time.time()*100)% 1e6), help = 'Set the seed to use for the random number generator. If none specified, will use the current time.')
parser.add_option('-v', '--verbose', action = 'store_true', help = 'Be verbose.')

opts, filenames = parser.parse_args()

# check options
wFmin = opts.waveform_f_min
oFmin = opts.overlap_f_min
if oFmin < wFmin:
    raise ValueError, "--waveform-f-min must be less than overlap-f-min"
default_sample_rate = opts.default_sample_rate
if numpy.log2(default_sample_rate) % 1 != 0.:
    raise ValueError, "--default-sample-rate must be a power of 2"
if opts.asd_file is None and opts.psd_model is None:
    raise ValueError, "must specify --asd-file or --psd-model"
if opts.asd_file is not None and not os.path.exists(opts.asd_file):
    raise ValueError, "asd-file %s not found" % opts.asd_file
ifo = opts.ifo
if opts.ifo is not None:
    ifo = ifo.upper()
    if len(ifo) != 2:
        raise ValueError("--ifo must be of format [site][number], e.g., 'H1'")
elif not opts.use_effective_distance:
    raise ValueError("If not specifying an ifo, must turn on " +\
        "use-effective-distance.")
if opts.fixed_distance_range is not None:
    min_dist, max_dist = map(float, opts.fixed_distance_range.split(','))
elif opts.scale_by_chirp_dist:
    raise ValueError("cannot use scale-by-chirp-dist if not using a " +\
        "fixed-distance-range (scaling by chirp distance doesn't make " +\
        "sense when using min/max SNR")
elif opts.min_snr is None or opts.max_snr is None:
    raise ValueError("must provide a min and max SNR if not specifying a " +
        "fixed-distance-range")

random.seed(opts.seed)

# initialize the workspace
workSpace = overlap_utils.WorkSpace()

# get the psd model to use
if opts.asd_file is None:
    psd_model = opts.psd_model

for fnum, infile in enumerate(filenames):
    if opts.verbose:
        print >> sys.stdout, "Analyzing file %s" % infile
    # connect to input
    working_filename = dbtables.get_connection_filename(infile, opts.tmp_space,
        verbose=opts.verbose)
    connection = sqlite3.connect(working_filename)
    if opts.tmp_space:
        dbtables.set_temp_store_directory(connection, opts.tmp_space,
            verbose=opts.verbose)
    # we'll drop the sim_inspiral param table to clear results from earlier
    # runs. We do this now because dbtables currently has a problem with
    # tables it doesn't recognize
    connection.cursor().execute('DROP TABLE IF EXISTS sim_inspiral_params')
    try:
        xmldoc = dbtables.get_xml(connection)
        this_process = process.register_to_xmldoc(xmldoc, __prog__,
            opts.__dict__)
    except:
        pass

    # create a sim_params table to store the weights
    create_sim_params_table(connection, delete_old=True)

    # cycle over the injections, calculating results for each
    if opts.verbose:
        print >> sys.stdout, "Cycling over injections..."
    # get the injections
    injections = waveform_utils.InjectionDict()
    try:
        injections.get_injections(connection, wFmin, calc_f_final=True,
            estimate_dur=True, verbose=opts.verbose)
    except RuntimeError:
        # this can happen if GetFinalFrequency in lalsimulation doesn't know
        # about this approximant; if so, turn off calc_f_final
        injections.get_injections(connection, wFmin, calc_f_final=False,
            estimate_dur=True, verbose=opts.verbose)

    for ii, inj in enumerate(injections.as_list):
        if opts.verbose:
            print >> sys.stdout, "Injection %i\r" %(ii+1), 
            sys.stdout.flush()

        # force the distance to be 1 Mpc
        inj.distance = 1.

        # randomize the sky location, polarization, inclination, phi0
        if opts.use_effective_distance:
            inj.inclination = 0.
            inj.dec = 0.
            inj.ra = 0.
            inj.polarization = 0.
            inj.phi0 = 0.
        else:
            inj.dec = numpy.arcsin(numpy.random.uniform(-1., 1.))
            inj.ra = numpy.random.uniform(0., 2*numpy.pi)
            inj.inclination = numpy.arccos(numpy.random.uniform(-1., 1.))
            inj.polarization = numpy.random.uniform(0., 2*numpy.pi)
            inj.phi0 = numpy.random.uniform(0., 2*numpy.pi)

        # check if f_final exists; if so calculate the sample rate to use 
        # from that
        if inj.f_final:
            sample_rate = int(2**(numpy.ceil(numpy.log2(inj.f_final))+1))
        else:
            sample_rate = opts.default_sample_rate

        # make the segment length a power of two
        seg_length = int(2**numpy.ceil(numpy.log2(inj.duration)+1))
        # since the duration estimate is based on the 2PN approximation,
        # the duration may be too short; we'll just put a floor at 2s
        if seg_length < 2:
            seg_length = 2
        df = 1./seg_length
      
        htilde = inj.get_fd_waveform(sample_rate, seg_length, ifo,
            inj.geocent_end_time - seg_length/2, store=False)

        # get the psd and needed workspace vectors
        if opts.asd_file is not None:
            psd = workSpace.get_psd_from_file(wFmin, sample_rate,
                seg_length, opts.asd_file, dyn_range_exp=0)
        else:
            psd = workSpace.get_psd(wFmin, sample_rate, seg_length,
                psd_model, dyn_range_exp=0)

        # calculate sigma
        sigma = filter.sigma(htilde, psd, oFmin)

        # get the distance ranges based on the optimal SNR
        if opts.fixed_distance_range is None:
            min_dist = sigma / opts.max_snr
            max_dist = sigma / opts.min_snr

        # get a distance to use, and the weights
        if opts.distribution == "volume":
            inj.distance = r_uniform_in_volume(min_dist, max_dist, 1)[0]
        elif opts.distribution == "distance":
            inj.distance = r_uniform_in_distance(min_dist, max_dist, 1)[0]
        elif opts.distribution == "gamma":
            dist0 = sigma / opts.fiducial_snr
            inj.distance = r_in_modified_gamma(dist0, max_dist,
                theta=2., r0_at='mode', N=1)
        else:
            raise ValueError("unrecognized --distribution %s; " %(
                opts.distribution), "see --help for options")

        # scale by chirp distance if desired
        if opts.scale_by_chirp_dist:
            scale_fac = (inj.mchirp/(2.8 * 0.25**0.6))**(5./6)
            inj.distance *= scale_fac
        else:
            scale_fac = 1.

        # get the weights that will need to be applied when
        # computing efficiency
        if opts.distribution == "gamma":
            weight = modified_gamma_weight(inj.distance, dist0, max_dist,
                theta=2., r0_at='mode')
            min_vol = 0.
        else:
            min_vol, weight = get_weights(opts.distribution, inj.distance,
                scale_fac*min_dist, scale_fac*max_dist)

        # if the ifo is None, we also need to divide by 2.26 to account for
        # the peanut shell
        if opts.use_effective_distance:
            min_vol /= 2.26**3.
            weight /= 2.26**3.

        # save to the database; in an abuse of columns, we'll store
        # the injection duration to alpha
        crs = connection.cursor()
        sqlquery = '''
            UPDATE
                sim_inspiral
            SET
            ''' + ',\n'.join(
                ['%s = %f' %(
                        waveform_utils.InjectionDict.inv_sim_inspiral_map[p],
                        getattr(inj, p))
                    for p in ['distance', 'dec', 'ra', 'polarization',
                                  'phi0', 'inclination', 'duration']
                ]) + '''
            WHERE simulation_id == "%s"'''
        crs.execute(sqlquery % inj.simulation_id)

        # save the weights
        end_time = inj.detector_end_time(ifo)
        sqlquery = '''
            INSERT INTO
                sim_inspiral_params
                (simulation_id, ifo, event_time, event_time_ns, sigmasq,
                 min_vol, weight)
            VALUES
                (?, ?, ?, ?, ?, ?, ?)'''
        crs.execute(sqlquery, (inj.simulation_id, ifo,
            end_time.gpsSeconds, end_time.gpsNanoSeconds,
            sigma**2., min_vol, weight))

    if opts.verbose:
        print >> sys.stdout, ""
        sys.stdout.flush()

    # save the database
    crs.close()
    connection.commit()
    connection.close()
    dbtables.put_connection_filename(infile, working_filename,
        verbose=opts.verbose)

if opts.verbose:
    print >> sys.stdout, "Finished!"
sys.exit(0)
