#! /usr/bin/env python

__prog__ = "pycbc_plot_volumes"
__author__ = "Collin Capano <collin.capano@ligo.org>"
__description__ = \
"""Creates plots of sensitive volumes as well as summary pages. Will also
gather plots from other progams and place them on the summary pages."""

import os, sys, shutil
from optparse import OptionParser
import numpy
from pycbc.plot import plot_utils
from pycbc.plot import efficiency
from pycbc.plot import plot_volumes


parser = OptionParser()
parser.add_option('-c', '--cache-file', help='Required. Cache file containing result databases.')
parser.add_option('-l', '--layer-config-file', help='Required. A config file containing the layer parameters to use.') 
parser.add_option('-T', '--threshold', type='float', help='Required. The value of the ranking stat to use as the threshold when computing efficiencies.')
parser.add_option('-R', '--ranking-stat', metavar='stat[:stat_label]', default=r'new_snr:$\hat{\rho}$', help='The ranking stat to use for computing efficiency. Can also specify a stat label for plotting (latex math should be enclosed in $ signs). Default is new_snr:$\hat{\rho}$.')
parser.add_option('-B', '--rank-by', default='max', help='Options are "max" or "min". If max (min) an injection will be considered found if its ranking stat is >= (<) the threshold. Default is max.')
parser.add_option('-r', '--stat-range', metavar='MIN_STAT,MAX_STAT[:log]', default='6,12', help='Stat range to use when creating volume vs. stat plots. Must specify both a minimum and a maximum. If would like the stat distribution to be log10, add ":log" after the max stat. Default is 6,12.')
parser.add_option('-N', '--min-ninj', type='int', default=2, help='Minimum number of injections that must exist in a block in in order to calculate volume. If a block has less then this, it will be skipped. Default is 2.')
parser.add_option('-p', '--subplots-cache', help='Load subplots for each tile from the given cache file.')
parser.add_option('-o', '--output-dir', help='Directory to save results to.')
parser.add_option('-u', '--user-tag', default='', help='Add a user tag to all output files.')
parser.add_option('', '--colormap', default='hot', help='What color map to use for fractional gain plots. Default is hot.')
parser.add_option('', '--minvol', type='float', default=None, help='Minimum volume to color. Default is to use whatever the minium volume found is.')
parser.add_option('', '--maxvol', type='float', default=None, help='Maximum volume to color. Default is to use whatever the maximum volume found is.')
parser.add_option('', '--fontsize', type='int', default=8, help='Fontsize to use in volume plots. Default is 8.')
parser.add_option('', '--logz', action='store_true', default=False, help='Make coloring log10.')
parser.add_option('', '--dpi', type='int', default=300, help='dpi to use for plots; default is 300')
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help = 'apply cut to injections; can specify multiple times')
parser.add_option('-M', '--mapper', default=None, help="Specify the location of a mapper.js JavaScript in order to highlight tiles on mouse over.")

opts, _ = parser.parse_args()

if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''
if not opts.cache_file:
    raise ValueError('cache-file required')
if not opts.output_dir:
    raise ValueError('output-dir required')

stat_info = opts.ranking_stat.split(':')
if len(stat_info) == 1:
    ranking_stat = stat_info[0]
    stat_label = ranking_stat.replace('_', ' ')
elif len(stat_info) == 2:
    ranking_stat, stat_label = stat_info
else:
    raise ValueError("ranking-stat not formatted correctly; see help")

stat_info = opts.stat_range.split(',')
if len(stat_info) != 2:
    raise ValueError("stat-range nto formatted correctly; see help")
min_stat, max_stat = stat_info
if max_stat.split(':') == 2:
    max_stat, stat_dist = max_stat.split(':')
    if stat_dist != 'log':
        raise ValueError('unrecognized stat distribution %s '%(stat_dist) +
            'given in stat-range; see help')
    stat_dist = True
else:
    stat_dist = False
min_stat = float(min_stat)
max_stat = float(max_stat)

# load the layers
print "loading layers"
layers = efficiency.create_layers_from_config(opts.layer_config_file,
    cube_type='single')

# create the directory structure: layer0 goes in the top level folder.
# Each sub-layer are placed in sub-folders. Every folder has an images
# directory where plots are stored.
imgdir = 'Images'
scriptdir = 'scripts/'
this_folder = '/'
for ii,layer in enumerate(layers):
    try:
        os.mkdir('%s%s' %(opts.output_dir, this_folder))
    except OSError:
        pass
    # make the images folder
    try:
        os.mkdir('%s%s%s' %(opts.output_dir, this_folder, imgdir))
    except OSError:
        pass
    # make scripts foler if necessary
    if opts.mapper is not None:
        try:
            os.mkdir('%s%s%s' %(opts.output_dir, this_folder, scriptdir))
        except OSError:
            pass
        shutil.copy2(opts.mapper, '%s%s%s' %(
            opts.output_dir, this_folder, scriptdir)) 
        mapper = '%s/%s' %(scriptdir, os.path.basename(opts.mapper))
    else:
        mapper = None
    layer.root_dir = opts.output_dir
    layer.web_dir = this_folder
    layer.images_dir = imgdir
    # update this_folder for the next lower layer
    this_folder = '%slayer%i/'%(this_folder, ii+1) 
    

print "getting results"
filenames = plot_utils.parse_results_cache(opts.cache_file)
results, id_map = plot_utils.get_injection_results(filenames, verbose=True)

apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))
if apply_cut:
    print "applying cuts"
    results = plot_utils.slice_results(results, apply_cut)

# set the top level data and ranking parameters
print "binning data"
layers[0].set_cube_data(results)
layers[0].set_ranking_params(ranking_stat, opts.rank_by, stat_label)

# now go down through the other layers, set the rest of the data
next_layer = layers[0].sub_layer
while next_layer is not None:
    next_layer.set_cube_data_using_super()
    next_layer.set_ranking_params(ranking_stat, opts.rank_by, stat_label)
    next_layer = next_layer.sub_layer

# Plot
print "plotting"
# if min, max vol aren't specified, get the minimum/maximum volumes across
# all of the tiles
minvol = opts.minvol
maxvol = opts.maxvol
if minvol is None or maxvol is None:
    Vs = numpy.array([child.get_volume(opts.threshold) for layer in layers \
        for child in layer.all_children if child.nsamples >= opts.min_ninj
        and child.get_volume(opts.threshold)[0] != 0.])
    if minvol is None:
        minvol = Vs.min()
    if maxvol is None:
        maxvol = Vs.max()

html_tmplt = '%slevel_%i-%s_%i.html'
# we'll create the plots from the bottom layers up, so that we can provide
# links to each lower layer
this_layer = layers[-1]
while this_layer is not None:
    # for the bottom layer, we'll also create html and volume vs stat plots
    # for the children
    this_is_lowest_layer = this_layer.sub_layer is None
    plot_volumes.plot_volume_vs_stat_from_layer(this_layer, min_stat,
        max_stat, stat_label, include_children=this_is_lowest_layer,
        user_tag=opts.user_tag, min_ninj=opts.min_ninj, logx=stat_dist,
        logy=True, nbins=20, threshold=opts.threshold, dpi=opts.dpi,
        verbose=True)

    plot_volumes.plot_volumes_from_layer(this_layer, opts.threshold,
        user_tag=opts.user_tag, min_ninj=opts.min_ninj,
        tmplt_label='', inj_label='', colormap=opts.colormap,
        maxvol=maxvol, minvol=minvol, fontsize=opts.fontsize,
        logz=opts.logz, dpi=opts.dpi, verbose=True)

    # if not the last layer, create the subvolumes plot
    if this_layer.sub_layer is not None:
        plot_volumes.plot_subvolumes_from_layer(this_layer, opts.threshold,
            user_tag=opts.user_tag, min_ninj=opts.min_ninj,
            tmplt_label='', inj_label='', colormap=opts.colormap,
            maxvol=maxvol, minvol=minvol,
            logz=opts.logz, dpi=opts.dpi, verbose=True)

    # write the html page
    # if this is the bottom layer, create pages for the children
    if this_is_lowest_layer:
        for ii,child in enumerate(this_layer.all_children):
            html_name = html_tmplt %(this_layer.web_dir, this_layer.level,
                'child', ii)
            child.create_html_page(this_layer.root_dir, html_name,
                mapper=None, threshold=opts.threshold)
    # the top layer page is the index page; otherwise we use the template
    for ii,parent in enumerate(this_layer.parents):
        if this_layer.level == 0:
            html_name = '/index.html'
        else:
            html_name = html_tmplt %(this_layer.web_dir, this_layer.level,
                'parent', ii)
        parent.create_html_page(this_layer.root_dir, html_name,
            mapper=mapper, threshold=opts.threshold)

    this_layer = this_layer.super_layer
